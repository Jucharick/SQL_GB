USE gb_db;

-- Транзакция — это набор последовательных операций с базой данных, соединенных в
-- одну логическую единицу.
-- Транзакцией называется атомарная группа запросов SQL, т. е. запросы, которые
-- рассматриваются как единое целое. Если база данных может выполнить всю группу
-- запросов, она делает это, но если любой из них не может быть выполнен в результате
-- Курс базы данных и SQL. Лекция 6 2
-- сбоя или по какой-то другой причине, не будет выполнен ни один запрос группы. Все
-- или ничего.

-- Изоляция — это свойство транзакции, которое позволяет скрывать изменения,
-- внесенные одной операцией транзакции при возникновении явления race condition

-- Процедура - это подпрограмма (например, подпрограмма) на обычном языке
-- сценариев, хранящаяся в базе данных.

-- ACID - это набор из четырех требований к транзакционной системе, обеспечивающих
-- максимально надежную и предсказуемую работу.


DROP TABLE IF EXISTS accounts;

CREATE TABLE accounts (
id INT PRIMARY KEY AUTO_INCREMENT,
user_id INT,
total DECIMAL (11,2) COMMENT 'Счет',
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Счета пользователей и интернет магазина';

INSERT INTO accounts (user_id, total)
VALUES
(4, 5000.00),
(3, 0.00),
(2, 200.00),
(NULL, 25000.00);

SELECT * FROM accounts;


START TRANSACTION;
-- Далее выполняем команды, входящие в транзакцию:
SELECT total FROM accounts WHERE user_id = 4;
-- Убеждаемся, что на счету пользователя достаточно средств:
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;
-- Снимаем средства со счета пользователя:
UPDATE accounts SET total = total + 2000 WHERE user_id IS NULL;
-- Чтобы изменения вступили в
-- силу, мы должны выполнить команду COMMIT
COMMIT;
-- cкрипт выполнять полностью: начиная от первой и до самой последней строчки

SELECT * FROM accounts;
-- Если команда проходит без ошибок, изменения фиксируются базой данных 


-- Если мы выясняем, что не можем завершить транзакцию, например, пользователь ее
-- отменяет или происходит еще что-то. Чтобы ее отметить мы можем воспользоваться
-- командой ROLLBACK:

START TRANSACTION;
SELECT total FROM accounts WHERE user_id = 4;
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;
UPDATE accounts SET total = total + 2000 WHERE user_id IS NULL;
ROLLBACK; -- Откат до исходного состояния


-- Для некоторых операторов нельзя выполнить откат при помощи оператора ROLLBACK.
-- К их числу
-- относят следующие команды:
-- ● CREATE INDEX
-- ● DROP INDEX
-- ● CREATE TABLE
-- ● DROP TABLE
-- ● TRUNCATE TABLE
-- ● ALTER TABLE
-- ● RENAME TABLE
-- ● CREATE DATABASE
-- ● DROP DATABASE
-- ● ALTER DATABASE
-- Не помещайте их в транзакции с другими операторами. Кроме того, существует ряд
-- операторов, которые неявно завершают транзакцию, как если бы был вызван оператор
-- COMMIT:
-- ● ALTER TABLE
-- ● BEGIN
-- ● CREATE INDEX
-- ● CREATE TABLE
-- ● CREATE DATABASE
-- ● DROP DATABASE
-- ● DROP INDEX
-- Курс базы данных и SQL. Лекция 6 5
-- ● DROP TABLE
-- ● DROP DATABASE
-- ● LOAD MASTER DATA
-- ● LOCK TABLES
-- ● RENAME
-- ● SET AUTOCOMMIT=1
-- ● START TRANSACTION
-- ● TRUNCATE TABLE
-- В случае сбоя в транзакции откат можно делать до некой точки сохранения -
-- SAVEPOINT.


-- Точка сохранения представляет собой место в последовательности событий
-- транзакции, которое может выступать в качестве промежуточной точки
-- восстановления. Откат текущей транзакции может быть выполнен не к началу
-- транзакции, а к точке сохранения.
-- Для работы с точками сохранения предназначены два оператора:
-- ● SAVEPOINT
-- ● ROLLBACK TO SAVEPOINT

START TRANSACTION;
SELECT total FROM accounts WHERE user_id = 4;
SAVEPOINT accounts_4;
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;
-- Допустим мы хотим отменить транзакцию и вернуться в точку сохранения. В этом случае мы можем
-- воспользоваться оператором ROLLBACK TO SAVEPOINT:
ROLLBACK TO SAVEPOINT accounts_4;
SELECT * FROM accounts;

-- Допускается создание нескольких точек сохранения. Если текущая транзакция имеет
-- точку сохранения с таким же именем, старая точка удаляется и устанавливается новая. Все
-- точки сохранения транзакций удаляются, если выполняется оператор COMMIT или
-- ROLLBACK без указания имени точки сохранения.


-- Транзакций недостаточно, если система не удовлетворяет принципу ACID.
-- Аббревиатура ACID расшифровывается как атомарность, согласованность, изолированность и
-- сохраняемость).
-- ● Atomicy — атомарность.
-- ● Consistency — согласованность.
-- ● Isolation — изолированность.
-- ● Durability — сохраняемость.
-- 
-- Атомарность подразумевает, что транзакция должна функционировать как единая
-- неделимая единица. Вся транзакция была либо выполняется, либо отменяется. Когда транзакции
-- атомарны, не существует такого понятия, как частично выполненная транзакция.
-- 
-- При выполнении принципа согласованности база данных должна всегда переходить
-- из одного непротиворечивого состояния в другое непротиворечивое состояние.
-- В нашем примере согласованность гарантирует, что сбой между двумя UPDATEкомандами не приведет к исчезновению 2000 рублей 
-- со счета пользователя. Транзакция просто не будет зафиксирована, и ни одно из изменений в этой транзакции
-- не будет отражено в базе данных.
-- 
-- Изолированность подразумевает, что результаты транзакции обычно невидимы
-- другим транзакциям, пока она не закончена. Это гарантирует, что, если в нашем
-- примере во время транзакции будет выполнен запрос на извлечение средств
-- пользователя, такой запрос по-прежнему будет видеть 2000 рублей на его счету.
-- 
-- Сохраняемость гарантирует, что изменения, внесенные в ходе транзакции, будучи
-- зафиксированными, становятся постоянными. Это означает, что изменения должны
-- быть записаны так, чтобы данные не могли быть потеряны в случае сбоя системы.


-- Уровни изоляции
-- Стандарт SQL
-- определяет четыре уровня изоляции с конкретными правилами, устанавливающими,
-- какие изменения видны внутри и вне транзакции, а какие нет:
-- ● READ UNCOMMITTED
-- ● READ COMMITTED
-- ● REPEATABLE READ
-- ● SERIALIZABLE

-- Более низкие уровни изоляции обычно допускают большую степень совместного
-- доступа и вызывают меньше накладных расходов. На первом уровне изоляции, READ
-- UNCOMMITTED, транзакции могут видеть результаты незафиксированных транзакций.
-- На практике READ UNCOMMITTED используется редко, поскольку его
-- производительность не намного выше, чем у других. На этом уровне вы видите
-- промежуточные результаты чужих транзакций, т.е. осуществляете грязное чтение.

-- Уровень READ COMMITTED подразумевает, что транзакция увидит только те
-- изменения, которые были уже зафиксированы другими транзакциями к моменту ее
-- начала. Произведенные ею изменения останутся невидимыми для других транзакций,
-- пока она не будет зафиксирована. На этом уровне возможен феномен
-- невоспроизводимого чтения. Это означает, что вы можете выполнить одну и ту же
-- команду дважды и получить различный результат.

-- Уровень изоляции REPEATABLE READ решает проблемы, которые возникают на
-- уровне READ UNCOMMITTED. Он гарантирует, что любые строки, которые
-- считываются в контексте транзакции, будут выглядеть такими же при
-- последовательных операциях чтения в пределах одной и той же транзакции, однако
-- теоретически на этом уровне возможен феномен фантомного чтения (phantom reads).
-- Он возникает в случае, если вы выбираете некоторый диапазон строк, затем другая
-- транзакция вставляет новую строку в этот диапазон, после чего вы выбираете тот же
-- диапазон снова. В результате вы увидите новую фантомную строку. 

-- Уровень изоляции REPEATABLE READ установлен по умолчанию.
-- Самый высокий уровень изоляции, SERIALIZABLE, решает проблему фантомного
-- чтения, заставляя транзакции выполняться в таком порядке, чтобы исключить
-- возможность конфликта. Уровень SERIALIZABLE блокирует каждую строку, которую
-- транзакция читает.


